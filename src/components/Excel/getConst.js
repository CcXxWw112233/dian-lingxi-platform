/**
 * APPTAG常量
 * @type {string}
 */
import { Resizable } from 'react-resizable'
import styles from './index.less'

export const APP_TAG = 'INSURANCE_APP'

export const ResizableTitle = props => {
  const { onResize, width, ...restProps } = props
  console.log(props)

  if (!width) {
    return <th {...restProps} style={{ position: 'relative' }} />
  }

  return (
    <Resizable
      width={width}
      height={0}
      handle={
        <span
          className={styles['react-resizable-handle']}
          onClick={e => {
            e.stopPropagation()
          }}
        />
      }
      onResize={onResize}
      draggableOpts={{ enableUserSelectHack: false }}
    >
      <th {...restProps} style={{ position: 'relative', width: width }} />
    </Resizable>
  )
}

export const components = {
  header: {
    cell: ResizableTitle
  }
}

export const handleResize = ({ width, index, columns }) => {
  const res = columns.map((item, i) => {
    if (i == index) {
      item.width = width
    }
    return item
  })
  console.log(res)
  return res
}

/**
 * 设置错误状态
 * @param {Array} columns 对应table中的列
 * @param {Array} data 对应table中的每一行数据
 * @param {String} text 表格中绑定的列columns 这里是 A B C D.... 表头
 * @param {String} name 表格中绑定的列的字段 这里是 number, name, type .... 等
 */
export const setErrorStageOrUpdate = ({
  columns = [],
  data = [],
  text,
  name
}) => {
  return data.map(item => {})
}

/**
 * MSDN中定义的DateTime对象的有效范围是：0001-01-01 00:00:00到9999-12-31 23:59:59。
 * UNIX时间戳的0按照ISO 8601规范为 ：1970-01-01T00:00:00Z。
 * 先考虑与年份无关的前三条规则，年份可统一写作 (?!0000)[0-9]{4}
 *下面仅考虑月和日的正则

  1. 包括平年在内的所有年份的月份都包含1-28日

  (0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])

  2. 包括平年在内的所有年份除2月外都包含29和30日

  (0[13-9]|1[0-2])-(29|30)

  3. 包括平年在内的所有年份1、3、5、7、8、10、12月都包含31日

  (0[13578]|1[02])-31)

  合起来就是除闰年的2月29日外的其它所有日期

  (?!0000)[0-9]{4}-((0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])|(0[13-9]|1[0-2])-(29|30)|(0[13578]|1[02])-31)

  接下来考虑闰年的实现

  1 : 四年一闰
  ([0-9]{2}(0[48]|[2468][048]|[13579][26])

  2 : 百年不闰，四百年再闰
  (0[48]|[2468][048]|[13579][26])00

  3 : 合起来就是所有闰年的2月29日
  ([0-9]{2}(0[48]|[2468][048]|[13579][26])|(0[48]|[2468][048]|[13579][26])00)-02-29)

  四条规则都已实现，且互相间没有影响，合起来就是所有符合DateTime范围的日期的正则

  ^((?!0000)[0-9]{4}-((0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-8])|(0[13-9]|1[0-2])-(29|30)|(0[13578]|1[02])-31)|([0-9]{2}(0[48]|[2468][048]|[13579][26])|(0[48]|[2468][048]|[13579][26])00)-02-29)$


  考虑到这个正则表达式仅仅是用作验证，所以捕获组没有意义，只会占用资源，影响匹配效率，所以可以使用非捕获组来进行优化。

  ^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$
 *
 *
 *
 */
// 2020-10-15
export const YYYYMMDDREG = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$/

// 2020/10/15
export const YYYYMMDD_REG_1 = /^(?:(?!0000)[0-9]{4}[\/](?:(?:0[1-9]|1[0-2])[\/](?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])[\/](?:29|30)|(?:0[13578]|1[02])[\/]31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)[\/]02[\/]29)$/

// 小时和分钟也可以是一位
// export const YYYYMMDD_HHMM = /^[1-2][0-9][0-9][0-9]-([1][0-2]|0?[1-9])-([12][0-9]|3[01]|0?[1-9]) ([01]?[0-9]|[2][0-3]):[0-5]?[0-9]$/

// 小时和分钟必须是两位 2020-10-15 09:40
export const YYYYMMDD_HHMM_REG = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29) ([01][0-9]|[2][0-3]):[0-5][0-9]$/

// 2020/10/15 09:40
export const YYYYMMDD_HHMM_REG_1 = /^(?:(?!0000)[0-9]{4}[\/](?:(?:0[1-9]|1[0-2])[\/](?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])[\/](?:29|30)|(?:0[13578]|1[02])[\/]31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)[\/]02[\/]29) ([01][0-9]|[2][0-3]):[0-5][0-9]$/
